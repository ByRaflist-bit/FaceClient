/*
 * FDPClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge by LiquidBounce.
 * https://github.com/SkidderMC/FDPClient/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.value.FloatValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.network.play.client.C01PacketChatMessage

object ChatBypass : Module("ChatBypass", Category.EXPLOIT, canBeEnabled = false, hideModule = false) {

    private val modeValue by ListValue("Mode", arrayOf("Null", "RandomChar", "Unicode", "RandomUnicode", "ToPinyin"), "Null")
    private val chanceValue by FloatValue("Chance", 0.2F, 0F..0.5F) { modeValue != "Unicode" }

    private val minUnicodeValue: IntegerValue = object : IntegerValue("MinUnicode", 1000, 0..100000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            if (newValue >= maxUnicodeValue.get()) {
                set(oldValue)
            }
        }
    }

    private val maxUnicodeValue: IntegerValue = object : IntegerValue("MaxUnicode", 20000, 0..100000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            if (newValue <= minUnicodeValue.get()) {
                set(oldValue)
            }
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        if (event.packet is C01PacketChatMessage) {
            val packet = event.packet
            val truncatedMessage = packet.message.take(100)
            if (truncatedMessage.startsWith("/")) return

            val newMessage = processMessage(truncatedMessage)
            packet.message = newMessage
        }
    }

    private fun processMessage(message: String): String {
        val chance = Math.random()
        val mode = modeValue.lowercase()

        return when (mode) {
            "null" -> processNullMode(message, chance)
            "randomchar" -> processRandomCharMode(message, chance)
            "unicode" -> processUnicodeMode(message)
            "randomunicode" -> processRandomUnicodeMode(message, chance)
            else -> message
        }
    }

    private fun processNullMode(message: String, chance: Double): String {
        val sb = StringBuilder()
        for (char in message.toCharArray()) {
            sb.append(char)
            if (chance < chanceValue) {
                sb.append("\uF8FF")
            }
        }
        return sb.toString()
    }

    private fun processRandomCharMode(message: String, chance: Double): String {
        val sb = StringBuilder()
        for (char in message.toCharArray()) {
            sb.append(char)
            if (chance < chanceValue) {
                sb.append((RandomUtils.nextInt(minUnicodeValue.get(), maxUnicodeValue.get())).toChar())
            }
        }
        return sb.toString()
    }

    private fun processUnicodeMode(message: String): String {
        return message.map { char ->
            if (char.code in 33..128) Character.toChars(char.code + 65248).joinToString("") else char.toString()
        }.joinToString("")
    }

    private fun processRandomUnicodeMode(message: String, chance: Double): String {
        return message.map { char ->
            if ((chance < chanceValue) && (char.code in 33..128)) Character.toChars(char.code + 65248).joinToString("") else char.toString()
        }.joinToString("")
    }

    override val tag: String
        get() = modeValue
}