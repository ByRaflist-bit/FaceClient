/*
 * FDPClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge by LiquidBounce.
 * https://github.com/SkidderMC/FDPClient/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.script.api.global.Chat
import net.ccbluex.liquidbounce.utils.ClientUtils.displayChatMessage
import net.ccbluex.liquidbounce.utils.PacketUtils.handlePacket
import net.ccbluex.liquidbounce.utils.PacketUtils.sendPacket
import net.ccbluex.liquidbounce.utils.extensions.isMoving
import net.ccbluex.liquidbounce.utils.extensions.tryJump
import net.ccbluex.liquidbounce.utils.inventory.InventoryUtils
import net.ccbluex.liquidbounce.value.*
import net.minecraft.init.Items
import net.minecraft.item.ItemStack
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayClient
import net.minecraft.network.play.client.*
import net.minecraft.network.play.server.S07PacketRespawn
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.network.play.server.S32PacketConfirmTransaction
import java.util.concurrent.LinkedBlockingQueue

object Disabler : Module("Disabler", Category.EXPLOIT, hideModule = false) {
    val startSprint by BoolValue("StartSprint", true)

    private val grimPlace by BoolValue("GrimPlace", false)
    private val grimDebug by BoolValue("GrimDebug", false) { grimPlace }

    private val vulcanScaffold by BoolValue("VulcanScaffold", false)
    private val vulcanPacketTick by IntegerValue("VulcanScaffoldPacketTick", 15, 1..20) { vulcanScaffold }

    val verusFly by BoolValue("VerusFly", false)

    val verusCombat by BoolValue("VerusCombat", false)
    private val onlyCombat by BoolValue("OnlyCombat", true) { verusCombat }

    val intaveFly by BoolValue("intaveFly", false)
    private var shouldDelay = false
    private val packets = LinkedBlockingQueue<Packet<INetHandlerPlayClient>>()

    val noRotationDisabler by BoolValue("NoRotationDisabler", false)

    val modifyModeValue by ListValue("Mode", arrayOf("ConvertNull", "Spoof", "Zero", "SpoofZero", "Negative", "OffsetYaw", "Invalid"), "NoRotationDisabler") { noRotationDisabler }
    val offsetAmountValue by FloatValue("OffsetAmount", 6f, -180f.. 180f) { noRotationDisabler }

    val basicDisabler by BoolValue("BasicDisabler", false)

    val cancelC00Value by BoolValue("CancelC00", true) { basicDisabler }
    val cancelC0FValue by BoolValue("CancelC0F", true) { basicDisabler }
    val cancelC0AValue by BoolValue("CancelC0A", true) { basicDisabler }
    val cancelC0BValue by BoolValue("CancelC0B", true) { basicDisabler }
    val cancelC07Value by BoolValue("CancelC07", true) { basicDisabler }
    val cancelC13Value by BoolValue("CancelC13", true) { basicDisabler }
    val cancelC03Value by BoolValue("CancelC03", true) { basicDisabler }
    val c03NoMoveValue by BoolValue("C03-NoMove", true) { basicDisabler }

    private val hypixelMotion by BoolValue("HypixelMotion", false)
    private val notWhenStarAvailable by BoolValue("NotWithStar", true) { hypixelMotion }

    val spigotSpam by BoolValue("SpigotSpam", false)
    val message by TextValue("Message", "/skill") { spigotSpam }

    private val debugValue by BoolValue("Debug", false)


    private var transaction = false
    var isOnCombat = false

    private var flags = 0
    private var airTicks = 0
    private var execute = false
    private var jump = false

    private val hasStar
        get() = InventoryUtils.findItem(36, 44, Items.nether_star) != null

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val player = mc.thePlayer ?: return
        val packet = event.packet

        // Basic Disabler
        if (basicDisabler) {
            when (packet) {
                is C00PacketKeepAlive -> if (cancelC00Value) {
                    event.cancelEvent()
                    debugMessage("Cancel C00-KeepAlive")
                }
                is C0FPacketConfirmTransaction -> if (cancelC0FValue) {
                    event.cancelEvent()
                    debugMessage("Cancel C0F-Transaction")
                }
                is C0APacketAnimation -> if (cancelC0AValue) {
                    event.cancelEvent()
                    debugMessage("Cancel C0A-Swing")
                }
                is C0BPacketEntityAction -> if (cancelC0BValue) {
                    event.cancelEvent()
                    debugMessage("Cancel C0B-Action")
                }
                is C07PacketPlayerDigging -> if (cancelC07Value) {
                    event.cancelEvent()
                    debugMessage("Cancel C07-Digging")
                }
                is C13PacketPlayerAbilities -> if (cancelC13Value) {
                    event.cancelEvent()
                    debugMessage("Cancel C13-Abilities")
                }
                is C03PacketPlayer -> if (cancelC03Value && !(packet is C03PacketPlayer.C04PacketPlayerPosition || packet is C03PacketPlayer.C05PacketPlayerLook || packet is C03PacketPlayer.C06PacketPlayerPosLook)) {
                    if (c03NoMoveValue && player.isMoving) return
                    event.cancelEvent()
                    debugMessage("Cancel C03-Flying")
                }
            }
        }

        // NoRotationDisabler
        if (noRotationDisabler && packet is C03PacketPlayer) {

            when (modifyModeValue) {
                "ConvertNull" -> {
                    if (packet.isMoving) {
                        sendPacket(
                            C03PacketPlayer.C04PacketPlayerPosition(
                                packet.x,
                                packet.y,
                                packet.z,
                                packet.onGround
                            )
                        )
                    } else {
                        sendPacket(C03PacketPlayer(packet.onGround))
                    }
                    event.cancelEvent()
                }

                "Spoof" -> {
                    if (packet.getRotating()) {
                        packet.yaw = player.rotationYaw
                        packet.pitch = player.rotationPitch
                    }
                }

                "Zero" -> {
                    if (packet.getRotating()) {
                        packet.yaw = 0.0f
                        packet.pitch = 0.0f
                    }
                }

                "SpoofZero" -> {
                    if (packet.isMoving) {
                        sendPacket(
                            C03PacketPlayer.C06PacketPlayerPosLook(
                                packet.x,
                                packet.y,
                                packet.z,
                                0.0f,
                                0.0f,
                                packet.onGround
                            )
                        )
                    } else {
                        sendPacket(
                            C03PacketPlayer.C06PacketPlayerPosLook(
                                player.posX,
                                player.posY,
                                player.posZ,
                                0.0f,
                                0.0f,
                                packet.onGround
                            )
                        )
                    }
                    event.cancelEvent()
                }

                "Negative" -> {
                    if (packet.getRotating()) {
                        packet.yaw = -packet.yaw
                        packet.pitch = -packet.pitch
                    }
                }

                "OffsetYaw" -> {
                    if (packet.getRotating()) {
                        packet.yaw += offsetAmountValue
                    }
                }
            }
        }

        /**
         * Working on Hypixel (Watchdog)
         * Tested on: play.hypixel.net
         * Credit: @localp / Nextgen
         * Original: @billionaire
         */
        if (hypixelMotion) {
            when (packet) {
                is S07PacketRespawn -> {
                    flags = 0
                    execute = false
                    jump = true
                }

                is S08PacketPlayerPosLook -> {
                    if (++flags >= 20) {
                        execute = false
                        flags = 0
                    }
                }
            }
        }

        if (grimPlace) {
            if (packet is C08PacketPlayerBlockPlacement && packet.placedBlockDirection in 0..5) {
                event.cancelEvent()
                sendPacket(
                    C08PacketPlayerBlockPlacement(
                        packet.position,
                        6 + packet.placedBlockDirection * 7,
                        packet.stack,
                        packet.placedBlockOffsetX,
                        packet.placedBlockOffsetY,
                        packet.placedBlockOffsetZ
                    )
                )

                if (grimDebug) {
                    displayChatMessage("§cModify §aPlace §cPacket§7.")
                }
            }
        }

        if (intaveFly) {
            if (packet is S08PacketPlayerPosLook) {
                if (player.capabilities.isFlying) {
                    shouldDelay = true
                    displayChatMessage("§cStart Canceling IntaveFly")
                }
            }

            if (packet is S32PacketConfirmTransaction && shouldDelay) {
                event.cancelEvent()
                packets.add(packet as Packet<INetHandlerPlayClient>)
            }
        }

        if (verusCombat) {
            if (player.ticksExisted <= 20) {
                isOnCombat = false
                return
            }

            if (onlyCombat && !isOnCombat) {
                return
            }

            /**
             * Works by just simply ignore transaction and not accepting them and send invalid one
             * to bypass Verus cancel transaction "patch" (not sending transaction for too long)
             * This could work on other anti-cheat that don't have a proper transaction handling system
             * But this will mostly be used on Verus, disabled any combat check related to transaction.
             *
             * Credit: @ghost / LB Nextgen
             */
            if (packet is S32PacketConfirmTransaction) {
                event.cancelEvent()
                sendPacket(C0FPacketConfirmTransaction(if (transaction) 1 else -1, if (transaction) -1 else 1, transaction), triggerEvent = false)
                transaction = !transaction
            }
        }
    }

    @EventTarget
    fun onJump(event: JumpEvent) {
        if (!hypixelMotion) return

        if (event.eventState == EventState.POST) {
            if (!jump) return
            jump = false
            execute = true
        }
    }

    @EventTarget
    fun onMotion(event: MotionEvent) {
        val player = mc.thePlayer ?: return

        if (!hypixelMotion) return
        if (event.eventState != EventState.PRE) return
        if (notWhenStarAvailable && hasStar) return

        // TODO: Add Warning Message

        when {
            player.onGround -> airTicks = 0
            else -> airTicks++
        }

        if (execute && airTicks >= 10) {
            if (airTicks % 2 == 0) {
                event.x += 0.095
            }
            player.setVelocity(0.0, 0.0, 0.0)
        }
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        val player = mc.thePlayer ?: return

        if (hypixelMotion) {
            if (jump) {
                player.tryJump()
            }
        }

        if (verusFly) {
            if (!isOnCombat && !player.isDead) {
                val pos = player.position.add(0, if (player.posY > 0) -255 else 255, 0) ?: return

                sendPacket(
                    C08PacketPlayerBlockPlacement(
                        pos,
                        256,
                        ItemStack(Items.water_bucket),
                        0F,
                        0.5F + Math.random().toFloat() * 0.44F,
                        0F
                    )
                )
            } else {
                isOnCombat = false
            }
        }

        if (vulcanScaffold) {
            if (!(player.isInWater || player.isInLava || player.isDead || player.isOnLadder)) {
                if (player.isMoving && player.ticksExisted % vulcanPacketTick == 0) {
                    sendPacket(C0BPacketEntityAction(player, C0BPacketEntityAction.Action.START_SNEAKING))
                    sendPacket(C0BPacketEntityAction(player, C0BPacketEntityAction.Action.STOP_SNEAKING))
                }
            }
        }
    }

    override fun onDisable() {
        airTicks = 0
        while (!packets.isEmpty()) {
            handlePacket(packets.take() as Packet<INetHandlerPlayClient?>)
        }
    }

    fun debugMessage(str: String) {
        if (debugValue) {
            Chat.print("§f$str")
        }
    }


    @EventTarget
    fun onAttack(event: AttackEvent) {
        isOnCombat = true
    }

    @EventTarget
    fun onWorld(event: WorldEvent) {
        isOnCombat = false
    }
}